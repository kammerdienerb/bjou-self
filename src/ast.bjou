# ast.bjou

module ast

using import "types.bjou"
using import "bucket_array.bjou"

using import "context.bjou"
using import "debug.bjou"
using import "utils.bjou"
using import "ty.bjou"

proc __inline__ add(array : bucket_array$ast ref, node : ast ref) : astref {
    debug_assert(not node.is_none(),
        "trying to allocate a \"nothing\" node in the bucket_array")
    return array.push(node)
}

proc __inline__ add(array : bucket_array$ast ref, node : ast) : astref {
    return add(array, getref(node))
}

proc __inline__ get_next_node_slot(array : bucket_array$ast ref) : astref {
    return array.push_blank()
}

type ast_flag_t = u64

abstract type astbase {
    flags      : u32
    cxt        : context
    module_idx : i32


    proc init(this) {
        this.flags      = 0
        this.module_idx = -1
    }

    proc __inline__ set_flag(this, flag : ast_flag) {
        this.flags = this.flags bor (1u64 bshl (flag as ast_flag_t))
    }

    proc __inline__ clear_flag(this, flag : ast_flag) {
        this.flags = this.flags band bneg (1u64 bshl (flag as ast_flag_t))
    }

    proc __inline__ get_flag(this, flag : ast_flag) : bool {
        return this.flags band (1u64 bshl (flag as ast_flag_t))
    }
}

type include_container {
    nodes : bucket_array$astref
}

include "ast/typed.bjou"
    include "ast/declarator.bjou"
    type all_declarators =
        ( declarator
        | arraydeclarator
        | slicedeclarator
        | dynamicarraydeclarator
        | pointerdeclarator
        | refdeclarator
        | sumdeclarator
        | tupledeclarator
        | procdeclarator )

    include "ast/declaration.bjou"
    type all_declarations =
        ( vardecl
        | constantdecl
        | procdef
        | templateprocdef
        | typedef
        | templatetypedef
        | enumdef)

    include "ast/expr.bjou"
    type all_exprs =
        ( integerliteral
        | floatliteral
        | stringliteral
        | charliteral
        | boolliteral
        | nothingliteral
        | qidentifier
        | namedarg
        | tupleliteral
        | initializerlist
        | sliceliteral
        | dynamicarrayliteral
        | lenexpr
        | newexpr
        | deleteexpr
        | sizeofexpr
        | addrexpr
        | derefexpr
        | notexpr
        | bnegexpr
        | asexpr
        | callexpr
        | subscriptexpr
        | dotexpr
        | multexpr
        | divexpr
        | modexpr
        | plusexpr
        | minusexpr
        | bshlexpr
        | bshrexpr
        | lssexpr
        | leqexpr
        | gtrexpr
        | geqexpr
        | equexpr
        | neqexpr
        | bandexpr
        | bxorexpr
        | borexpr
        | andexpr
        | orexpr
        | assignexpr
        | multassignexpr
        | divassignexpr
        | modassignexpr
        | plusassignexpr
        | minusassignexpr)

include "ast/statement.bjou"
type all_stmts =
    ( printstmt
    | returnstmt
    | ifstmt
    | elsestmt
    | forstmt
    | foreachstmt
    | whilestmt
    | dowhilestmt
    | breakstmt
    | continuestmt
    | importstmt
    | usingstmt
    | includestmt)

include "ast/this.bjou"
include "ast/template.bjou"
include "ast/arglist.bjou"
include "ast/directive.bjou"
include "ast/moduledecl.bjou"
type other_nodes =
    ( thisparam
    | thistype
    | templatedef
    | templateinst
    | arglist
    | directive
    | moduledecl)

type ast    = (all_declarators | all_declarations | all_exprs | all_stmts | other_nodes | none)
type astref = (ast ref | none)

enum ast_flag {
    NO_MANGLE,
    IS_INLINE,
    IS_EXTERN,
    IS_VARARG,
    ANONYMOUS_PROC,
    C_VARARG,
    LEAF_EXPR,
    PAREN,
    IS_DESTRUCTURE,
    FOREACH_TAKE_REF,
    TYPE_ALIAS,
    OPENS_SCOPE
}

proc unsafe_baseref(this : ast ref) : astbase ref {
    debug_assert(not this.is_none(), "unsafe_baseref(ast ref) failed")
    return @(\__sum_data{ this } as astbase*)
}

proc unsafe_baseref(this : astref) : astbase ref {
    debug_assert(not this.is_none(), "unsafe_baseref(astref) failed")
    return unsafe_baseref(unsafe_ast_ref(this))
}

proc unsafe_ast_ref(this : astref) : ast ref {
    # @bad
    # Assuming equivalence of ref and pointer here.
    return @@(\__sum_data{ this } as ast**)
}

proc new_void_declarator(array : bucket_array$ast ref) : declarator {
    d           := declarator.create()
    d.identifier = add(array, qidentifier.create("void"))

    return d
}
