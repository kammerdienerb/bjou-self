# scope.bjou

module scope


using import "hash_table.bjou"
using import "pair.bjou"
using import "bucket_array.bjou"
using import "thread.bjou"


using import "hash_functions.bjou"
using import "ast.bjou"
using import "ui.bjou"
using import "debug.bjou"
using import "utils.bjou"

type symbol_table = hash_table$(string, astref, str_hasher)

type overload_set {
    procs : astref[...]


    proc create() : overload_set {
        return { overload_set:
            .procs = [...astref]
        }
    }
}
type overload_table  = hash_table$(string, overload_set, str_hasher)

type scope {
    parent_scope : (scope ref | none)
    is_module    : bool
    module_name  : string
    sub_scopes   : scope*[...]
    symbols      : symbol_table
    overloads    : overload_table


    proc create_common(parent_scope : scope ref) : scope {
        return { scope:
            .parent_scope = parent_scope,
            .sub_scopes   = [...scope*],
            .symbols      = symbol_table.create(),
            .overloads    = overload_table.create(),
        }
    }

    proc create(parent_scope : scope ref, module_name : string ref) : scope {
        r := scope.create_common(parent_scope)
        r.is_module   = true
        r.module_name = module_name.copy()

        return r
    }

    proc create(parent_scope : scope ref) : scope {
        r := scope.create_common(parent_scope)
        r.is_module   = false
        r.module_name = str()

        return r
    }

    proc is_in_module(this) : bool {
        m_s : (scope ref | none) = this

        while s : scope ref = m_s {
            if s.is_module {
                return true
            }

            m_s = s.parent_scope
        }

        return false
    }

    proc add_subscope(this, sub_scope : scope) : scope ref {
        scope_ref := alloc_sub_scope(sub_scope)
        this.sub_scopes.push(&scope_ref)
        return scope_ref
    }

    # @libc
    proc show(this, indent_level : u32) {
        printf("%*s", 4 * indent_level, "")
        if this.is_module {
            printf("module %s ", this.module_name.c_str())
        }
        printf("{\n")
        indent_level += 1
        for it := this.symbols.iter(); not it.is_end(); it.next() {
            printf("%*s", 4 * indent_level, "")
            printf("%s", it.val().first.c_str())
            if it.val().second.is_none() {
                if overload_search : pair$(string ref, overload_set ref) = this.overloads.lookup(it.val().first) {
                    printf(" (%d overloads)", |overload_search.second.procs|)
                } else debug_assert(false, "overload set not found")
            }
            printf("\n")
        }

        if |this.sub_scopes| {
            printf("\n")
        }

        foreach sub_ptr in this.sub_scopes {
            (@sub_ptr).show(indent_level)
        }
        indent_level -= 1
        printf("%*s}\n", 4 * indent_level, "")
    }
}

type module_scope_table = hash_table$(string, i32, str_hasher)

type globalscope extends scope {
    module_scopes : module_scope_table


    proc create() : globalscope {
        return { globalscope:
            .sub_scopes         = [...scope*],
            .symbols            = symbol_table.create(),
            .overloads          = overload_table.create(),
            .is_module          = false,
            .module_name        = str(),
            .module_scopes      = module_scope_table.create(),
        }
    }

    proc get_module_scope_by_idx(this, idx : i32) : scope ref {
        module_scope := this.sub_scopes[idx]
        debug_assert(module_scope.is_module, "not a module scope")

        return @module_scope
    }

    proc get_or_add_module_scope_idx(this, module_name : string ref) : i32 {
        if search : pair$(string ref, i32 ref) = this.module_scopes.lookup(module_name) {
            return search.second
        }

        idx := len(this.sub_scopes)
        scope_ref := this.add_subscope(scope.create(this, module_name))
        scope_ref.is_module = true
        this.module_scopes.insert(module_name, idx)

        return idx
    }

    proc show(this) {
        printf("global scope ")
        scope.show(this, 0)
    }
}

proc find_in_scope(s : scope ref, name : string ref) : (ast ref | overload_set ref | none) {
    m_scope : (scope ref | none) = s

    s_is_in_module := s.is_in_module()

    while search_scope : scope ref = m_scope {
        # Don't look at the global scope if in a module.
        # This allows symbols to be shadowed within modules
        # (which is good because modules won't know the global
        # symbols of the codebase their imported to), but still
        # prevents symbol shadowing at global scope.
        if s_is_in_module and search_scope.parent_scope.is_none() {
            break
        }

        m_search := search_scope.symbols.lookup(name)
        if search : pair$(string ref, astref ref) = m_search {
            if node : ast ref = search.second {
                return node
            } else {
                m_overload_search := search_scope.overloads.lookup(name)
                if overload_search : pair$(string ref, overload_set ref) = m_overload_search {
                    return overload_search.second
                }
            }
        }
        m_scope = search_scope.parent_scope
    }

    return nothing
}

proc resolve_identifier(s : scope ref, i : qidentifier ref) {

}

proc add_nodes_to_top_level_scope(global_scope : globalscope ref, nodes : bucket_array$astref ref, type_nodes : bucket_array$astref ref) {
    for it := nodes.iter(); not it.is_end(); it.next() {
        m_node := it.val()
        if node : ast ref = m_node {
            add_single_node_to_top_level_scope(global_scope, node, type_nodes)
        }
    }
}

proc add_single_node_to_top_level_scope(global_scope : globalscope ref, node : ast ref, type_nodes : bucket_array$astref ref) {
    if decl : declaration = node {
        # If this node defines a type, add it to type_nodes so that it can
        # be worked on later when building the type table.
        if      type_node : typedef         = node { type_nodes.push(node) }
        else if type_node : templatetypedef = node { type_nodes.push(node) }
        else if type_node : enumdef         = node { type_nodes.push(node) }


        # Do this first so that the typedef declaration names don't
        # have the module prefix yet.
        # This avoid double prepending the module name.
        if ty_def : typedef = node {
            add_typedef_declarations_to_top_level_scope(global_scope, ty_def, type_nodes)
        }

        module_idx := unsafe_baseref(node).module_idx
        if module_idx == -1 {
            add_to_scope(global_scope, node)
        } else {
            module_scope := global_scope.get_module_scope_by_idx(module_idx)
            add_to_scope(module_scope, node)
        }
    } else if inc : includestmt = node {
        if inc_container : include_container ref = inc.container {
            add_nodes_to_top_level_scope(global_scope, inc_container.nodes, type_nodes)
        } else debug_assert(false, "missing include_container for includestmt")
    }
}

proc add_typedef_declarations_to_top_level_scope(global_scope : globalscope ref, ty_def : typedef, type_nodes : bucket_array$astref ref) {
    foreach child in ty_def.declarations {
        child_node : ast ref = unsafe_ast_ref(child)
        if field : vardecl = child_node {
            # Don't add symbols for variable fields.
        } else if child_decl : declaration = child_node {
            child_decl.name       = concat(ty_def.name.copy(), str("."), child_decl.name)
            child_decl.module_idx = ty_def.module_idx
            add_single_node_to_top_level_scope(global_scope, child_node, type_nodes)
        } else debug_assert(false, "what kind of node is in this typedef?")
    }
}

proc add_to_scope(s : scope ref, node : ast ref) {
    if decl : declaration = node {

        if s.is_module {
            decl.name = concat(s.module_name.copy(), str("::"), decl.name)
        }

        search := find_in_scope(s, decl.name)
        if search.is_none() {
            # Normal symbol.
            # The symbol table is taking ownership of 'name'.
            s.symbols.insert(decl.name, node)
        } else {
            if ex : ast ref = search {
                # The symbol exists, but isn't in an overload_set.
                if ex_decl : declaration = ex {
                    if not can_be_overload(ex) {
                        redefinition_error(decl.name, decl, ex_decl)
                    } else if not can_be_overload(node) {
                        redefinition_cant_overload_error(decl.name, decl, ex_decl)
                    }

                    init_overload(s, decl.name, ex, node)

                } else debug_assert(false, "not a declaration")
            } else if ov : overload_set ref = search {
                # Already an overloaded procedure moved to an overload_set.
                if not can_be_overload(node) {
                    ex_proc := unsafe_ast_ref(ov.procs.back())
                    if ex_decl : declaration = ex_proc {
                        redefinition_cant_overload_error(decl.name, decl, ex_decl)
                    } else debug_assert(false, "not a declaration")
                }
                add_overload(s, decl.name, node)
            }
        }

    } else debug_assert(false, "not a declaration")
}

proc recursively_build_subscopes(parent_scope : scope ref, node : ast ref) {
    debug_assert(unsafe_baseref(node).get_flag(ast_flag.OPENS_SCOPE), "node doesn't open a scope")

    if      p : procdef         = node { build_subscope(parent_scope, p) }
    else if i : ifstmt          = node { build_subscope(parent_scope, i) }
    else if e : elsestmt        = node { build_subscope(parent_scope, e) }
    else if f : forstmt         = node { build_subscope(parent_scope, f) }
    else if f : foreachstmt     = node { build_subscope(parent_scope, f) }
    else if w : whilestmt       = node { build_subscope(parent_scope, w) }
    else if d : dowhilestmt     = node { build_subscope(parent_scope, d) }
    else debug_assert(false, "node hash OPENS_SCOPE set, but isn't handled")
}

proc build_subscope_block(parent_scope : scope ref, block : astref[...]) {
    foreach m_stmt in block {
        node := unsafe_ast_ref(m_stmt)
        if decl : declaration = node {
            add_to_scope(parent_scope, node)
        }

        if unsafe_baseref(node).get_flag(ast_flag.OPENS_SCOPE) {
            recursively_build_subscopes(parent_scope, node)
        }
    }
}

proc build_subscope(parent_scope : scope ref, p : procdef ref) {
    new_scope := parent_scope.add_subscope(scope.create(parent_scope))

    foreach m_param in p.param_decls {
        node := unsafe_ast_ref(m_param)
        if param : vardecl = node {
            add_to_scope(new_scope, node)
        }
    }

    build_subscope_block(new_scope, p.stmts)

}

proc build_subscope(parent_scope : scope ref, i : ifstmt ref) {
    new_scope := parent_scope.add_subscope(scope.create(parent_scope))
    if i.get_flag(ast_flag.IS_DESTRUCTURE) {
        add_to_scope(new_scope, unsafe_ast_ref(i.cond))
    }
    build_subscope_block(new_scope, i.stmts)
}

proc build_subscope(parent_scope : scope ref, e : elsestmt ref) {
    new_scope := parent_scope.add_subscope(scope.create(parent_scope))
    build_subscope_block(new_scope, e.stmts)
}

proc build_subscope(parent_scope : scope ref, f : forstmt ref) {
    new_scope := parent_scope.add_subscope(scope.create(parent_scope))
    if ini : ast ref = f.ini {
        add_to_scope(new_scope, ini)
    }
    build_subscope_block(new_scope, f.stmts)
}

proc build_subscope(parent_scope : scope ref, f : foreachstmt ref) {
    new_scope := parent_scope.add_subscope(scope.create(parent_scope))
    if var : ast ref = f.var {
        add_to_scope(new_scope, var)
    }
    build_subscope_block(new_scope, f.stmts)
}

proc build_subscope(parent_scope : scope ref, w : whilestmt ref) {
    new_scope := parent_scope.add_subscope(scope.create(parent_scope))
    if w.get_flag(ast_flag.IS_DESTRUCTURE) {
        add_to_scope(new_scope, unsafe_ast_ref(w.cond))
    }
    build_subscope_block(new_scope, w.stmts)
}

proc build_subscope(parent_scope : scope ref, d : dowhilestmt ref) {
    new_scope := parent_scope.add_subscope(scope.create(parent_scope))
    build_subscope_block(new_scope, d.stmts)
}

proc init_overload(s : scope ref, name : string ref, existing_proc : ast ref, new_proc : ast ref) {
    # Make a new overload_set and move symbols to it.
    # The overload_table is taking ownership of 'name'.

    inserted := s.overloads.insert(name, overload_set.create())
    inserted.second.procs.push(existing_proc)
    inserted.second.procs.push(new_proc)

    # Mark the symbol table entry as an overload by replacing the
    # ast ref with 'nothing'.
    s.symbols.insert(name, nothing)
}

proc add_overload(s : scope ref, name : string ref, new_proc : ast ref) {
    if search : pair$(string ref, overload_set ref) = s.overloads.lookup(name) {
        search.second.procs.push(new_proc)
    } else debug_assert(false, "missing overload set")
}

proc can_be_overload(node : ast ref) : bool {
    is_overloadable := false

    if      p   : procdef         = node    { is_overloadable = true }
    else if t_p : templateprocdef = node    { is_overloadable = true }

    return is_overloadable
}

proc redefinition_error(name : string ref, decl : declaration ref, ex : declaration ref) {
    err_str := str("Redefinition of '")
    err_str.append(name)
    err_str.append("'.")

    ui::error_builder.create()
        .with_message(err_str.c_str())
        .add_location(decl.name_cxt)
        .add_location("Previous declaration:", ex.name_cxt)
        .report()
}

proc redefinition_cant_overload_error(name : string ref, decl : declaration ref, ex : declaration ref) {
    err_str := str("Redefinition of '")
    err_str.append(name)
    err_str.append("'.")

    ui::error_builder.create()
        .with_message(err_str.c_str())
        .add_location(decl.name_cxt)
        .add_note("non-procedure symbol can't be added as an overload")
        .add_location("Previous declaration:", ex.name_cxt)
        .report()
}
